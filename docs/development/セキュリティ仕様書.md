# Claude Code Client セキュリティ仕様書

**バージョン**: 1.0  
**作成日**: 2025-06-25  
**セキュリティレベル**: 高度  
**準拠基準**: OWASP Top 10, ISO 27001  

---

## 目次

1. [セキュリティ概要](#1-セキュリティ概要)
2. [脅威分析・リスク評価](#2-脅威分析リスク評価)
3. [認証・認可システム](#3-認証認可システム)
4. [データ保護・暗号化](#4-データ保護暗号化)
5. [インフラセキュリティ](#5-インフラセキュリティ)
6. [アプリケーションセキュリティ](#6-アプリケーションセキュリティ)
7. [監査・ログ](#7-監査ログ)
8. [インシデント対応](#8-インシデント対応)
9. [セキュリティ運用](#9-セキュリティ運用)

---

## 1. セキュリティ概要

### 1.1 セキュリティ方針
Claude Code Client は開発者の機密情報・コードを扱うため、以下の原則に基づき高度なセキュリティを実装する：

- **最小権限の原則**: ユーザー・プロセスに必要最小限の権限のみ付与
- **多層防御**: 複数のセキュリティ層による防御体制構築
- **ゼロトラスト**: 内部・外部を問わず全通信を検証
- **暗号化**: 保存時・転送時データの完全暗号化
- **監査**: 全操作の詳細ログ記録・監視

### 1.2 セキュリティ要件レベル
```
機密性 (Confidentiality): 高
完全性 (Integrity): 高  
可用性 (Availability): 中
認証 (Authentication): 高
認可 (Authorization): 高
監査性 (Auditability): 高
```

### 1.3 保護対象資産
```
最高機密:
- ユーザーパスワード・認証情報
- Claude API キー・認証トークン
- 暗号化キー・証明書

機密:
- ユーザーソースコード・プロジェクト情報
- セッション状態・コンテキストデータ
- システム設定・環境変数

内部使用:
- 操作ログ・監査ログ
- システム監視データ
- パフォーマンス統計
```

---

## 2. 脅威分析・リスク評価

### 2.1 STRIDE脅威モデル

#### 2.1.1 なりすまし (Spoofing)
```yaml
脅威:
  - 認証情報盗取による不正ログイン
  - セッション乗っ取り攻撃
  - API キー漏洩による不正利用

対策:
  - 多要素認証 (MFA) 導入準備
  - JWT トークン短期間有効期限
  - IP アドレス・ユーザーエージェント検証
  - ログイン異常検知・通知

リスク評価: 高 → 中（対策後）
```

#### 2.1.2 改ざん (Tampering)
```yaml
脅威:
  - コード・ファイル不正改変
  - データベース直接改ざん
  - 通信経路でのデータ改変

対策:
  - ファイル整合性監視
  - データベースアクセス制御
  - TLS 1.3 通信暗号化
  - デジタル署名・ハッシュ検証

リスク評価: 中 → 低（対策後）
```

#### 2.1.3 否認 (Repudiation)
```yaml
脅威:
  - 操作実行の否認
  - 不正アクセスの証拠隠滅

対策:
  - 詳細監査ログ記録
  - タイムスタンプ・デジタル署名
  - 改ざん防止ログ保存
  - 操作録画機能（ターミナル）

リスク評価: 中 → 低（対策後）
```

#### 2.1.4 情報漏洩 (Information Disclosure)
```yaml
脅威:
  - データベース情報漏洩
  - ログファイル機密情報漏洩
  - メモリダンプ攻撃

対策:
  - データベース暗号化
  - ログ機密情報マスキング
  - メモリ暗号化・クリア
  - アクセス制御・権限分離

リスク評価: 高 → 中（対策後）
```

#### 2.1.5 サービス拒否 (Denial of Service)
```yaml
脅威:
  - DDoS 攻撃
  - リソース枯渇攻撃
  - API レート制限回避攻撃

対策:
  - レート制限・IP ブロック
  - リソース使用量制限
  - ロードバランサー・CDN
  - 異常トラフィック検知

リスク評価: 中 → 低（対策後）
```

#### 2.1.6 権限昇格 (Elevation of Privilege)
```yaml
脅威:
  - コンテナエスケープ
  - 管理者権限奪取
  - データベース権限昇格

対策:
  - Docker セキュリティ強化
  - 最小権限設定
  - sudo 権限制限
  - 権限監視・異常検知

リスク評価: 高 → 中（対策後）
```

### 2.2 OWASP Top 10 対策

#### A01: Broken Access Control
```yaml
対策:
  - ロールベースアクセス制御 (RBAC)
  - リソース毎の詳細権限設定
  - セッション・ユーザー分離
  - API エンドポイント認可チェック

実装:
  - FastAPI Depends() による権限チェック
  - データベースレベルの Row Level Security
  - ファイルシステム権限制御
```

#### A02: Cryptographic Failures
```yaml
対策:
  - AES-256 強力暗号化
  - TLS 1.3 通信暗号化
  - 安全な鍵管理システム
  - ソルト付きハッシュ化

実装:
  - cryptography ライブラリ使用
  - bcrypt パスワードハッシュ化
  - 環境変数・専用ボルトでの鍵管理
```

#### A03: Injection
```yaml
対策:
  - パラメータ化クエリ
  - 入力値検証・サニタイズ
  - ORM 使用による SQL インジェクション防止
  - コマンドインジェクション対策

実装:
  - SQLAlchemy ORM 使用
  - Pydantic バリデーション
  - subprocess 安全な実行
  - ファイルパス正規化
```

---

## 3. 認証・認可システム

### 3.1 認証アーキテクチャ

```python
# JWT トークン設定
JWT_CONFIG = {
    "algorithm": "RS256",  # RSA 公開鍵暗号
    "access_token_expire": 3600,  # 1時間
    "refresh_token_expire": 2592000,  # 30日
    "issuer": "claude-code-client",
    "audience": "claude-code-users",
    
    # 鍵設定
    "private_key_path": "/secure/jwt-private.pem",
    "public_key_path": "/secure/jwt-public.pem",
    "key_rotation_days": 90,
    
    # セキュリティ設定
    "token_blacklist_enabled": True,
    "concurrent_session_limit": 5,
    "login_attempt_limit": 5,
    "lockout_duration_minutes": 15
}
```

### 3.2 パスワードセキュリティ

```python
# パスワード要件
PASSWORD_POLICY = {
    "min_length": 8,
    "max_length": 128,
    "require_uppercase": True,
    "require_lowercase": True,
    "require_digits": True,
    "require_special_chars": False,
    "forbidden_passwords": [
        "password", "123456", "qwerty", "admin", "claude"
    ],
    
    # ハッシュ設定
    "bcrypt_rounds": 12,
    "password_history": 5,  # 過去5回のパスワード再利用禁止
    "expiry_days": 90  # パスワード90日有効期限
}

# パスワードハッシュ実装
from passlib.context import CryptContext

pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12
)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)
```

### 3.3 多要素認証 (MFA) 準備

```python
# TOTP 設定（将来実装）
MFA_CONFIG = {
    "enabled": False,  # 現在は無効、将来有効化
    "totp_issuer": "Claude Code Client",
    "totp_period": 30,
    "totp_digits": 6,
    "backup_codes_count": 10,
    
    # 必須化設定
    "required_for_admin": True,
    "required_for_sensitive_ops": True,
    "grace_period_days": 30
}
```

### 3.4 セッション管理

```python
# セッション設定
SESSION_CONFIG = {
    "cookie_name": "claude_session",
    "cookie_secure": True,
    "cookie_httponly": True,
    "cookie_samesite": "strict",
    "cookie_domain": None,  # 同一ドメインのみ
    
    # セキュリティ設定
    "regenerate_on_login": True,
    "invalidate_on_logout": True,
    "concurrent_limit": 3,
    "idle_timeout_minutes": 30,
    "absolute_timeout_hours": 8,
    
    # 監視設定
    "track_ip_changes": True,
    "track_user_agent": True,
    "suspicious_activity_detection": True
}
```

### 3.5 権限管理 (RBAC)

```python
# ロール定義
ROLES = {
    "admin": {
        "description": "システム管理者",
        "permissions": ["*"],  # 全権限
        "resource_limits": {"unlimited": True}
    },
    "developer": {
        "description": "開発者",
        "permissions": [
            "session:create", "session:read", "session:update", "session:delete",
            "project:create", "project:read", "project:update", "project:delete",
            "worktree:create", "worktree:read", "worktree:update", "worktree:delete",
            "file:read", "file:write", "file:upload", "file:download",
            "notification:read", "notification:update",
            "collaboration:create", "collaboration:join"
        ],
        "resource_limits": {
            "max_sessions": 10,
            "max_projects": 20,
            "max_worktrees": 50,
            "storage_gb": 10,
            "api_calls_per_hour": 1000
        }
    },
    "viewer": {
        "description": "閲覧者",
        "permissions": [
            "session:read", "project:read", "file:read",
            "notification:read"
        ],
        "resource_limits": {
            "max_sessions": 3,
            "max_projects": 5,
            "storage_gb": 1,
            "api_calls_per_hour": 100
        }
    }
}

# 権限チェック実装
def check_permission(user: User, permission: str, resource_id: str = None) -> bool:
    user_role = user.role
    role_permissions = ROLES[user_role]["permissions"]
    
    # 管理者は全権限
    if "*" in role_permissions:
        return True
    
    # 具体的権限チェック
    if permission in role_permissions:
        # リソース所有者チェック
        if resource_id and not is_resource_owner(user.id, resource_id):
            return False
        return True
    
    return False
```

---

## 4. データ保護・暗号化

### 4.1 暗号化仕様

```python
# 暗号化設定
ENCRYPTION_CONFIG = {
    # データベース暗号化
    "database": {
        "algorithm": "AES-256-GCM",
        "key_derivation": "PBKDF2",
        "iterations": 100000,
        "salt_length": 32,
        "iv_length": 16,
        "tag_length": 16
    },
    
    # ファイル暗号化
    "file_storage": {
        "algorithm": "AES-256-CBC", 
        "block_size": 16,
        "key_rotation_days": 30
    },
    
    # セッションデータ暗号化
    "session_data": {
        "algorithm": "AES-256-GCM",
        "compression": True,
        "key_per_session": True
    },
    
    # 通信暗号化
    "transport": {
        "tls_version": "1.3",
        "cipher_suites": [
            "TLS_AES_256_GCM_SHA384",
            "TLS_CHACHA20_POLY1305_SHA256",
            "TLS_AES_128_GCM_SHA256"
        ]
    }
}
```

### 4.2 鍵管理システム

```python
# 鍵管理設定
KEY_MANAGEMENT = {
    "storage_type": "environment",  # environment, vault, hsm
    "key_hierarchy": {
        "master_key": {
            "env_var": "MASTER_ENCRYPTION_KEY",
            "length": 256,
            "rotation_days": 90
        },
        "database_key": {
            "derived_from": "master_key",
            "purpose": "database_encryption"
        },
        "session_key": {
            "derived_from": "master_key", 
            "purpose": "session_encryption"
        },
        "file_key": {
            "derived_from": "master_key",
            "purpose": "file_encryption"
        }
    },
    
    # 鍵ローテーション
    "rotation_schedule": {
        "master_key": "90_days",
        "derived_keys": "30_days",
        "session_keys": "24_hours"
    },
    
    # バックアップ
    "backup_encrypted": True,
    "backup_location": "/secure/key_backup/",
    "backup_retention_days": 365
}

# 鍵管理実装
import os
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import secrets

class KeyManager:
    def __init__(self):
        self.master_key = self._load_master_key()
    
    def _load_master_key(self) -> bytes:
        key_b64 = os.getenv("MASTER_ENCRYPTION_KEY")
        if not key_b64:
            raise ValueError("Master encryption key not found")
        return base64.b64decode(key_b64)
    
    def derive_key(self, purpose: str, salt: bytes = None) -> bytes:
        if salt is None:
            salt = secrets.token_bytes(32)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        return kdf.derive(self.master_key + purpose.encode())
    
    def encrypt_data(self, data: bytes, key: bytes) -> tuple[bytes, bytes, bytes]:
        iv = secrets.token_bytes(16)
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv))
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(data) + encryptor.finalize()
        return ciphertext, iv, encryptor.tag
    
    def decrypt_data(self, ciphertext: bytes, key: bytes, iv: bytes, tag: bytes) -> bytes:
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag))
        decryptor = cipher.decryptor()
        return decryptor.update(ciphertext) + decryptor.finalize()
```

### 4.3 データ分類・保護レベル

```python
# データ分類
DATA_CLASSIFICATION = {
    "public": {
        "encryption": False,
        "access_control": "public",
        "retention_days": 365,
        "backup_frequency": "weekly"
    },
    "internal": {
        "encryption": True,
        "encryption_algorithm": "AES-256-CBC",
        "access_control": "authenticated_users",
        "retention_days": 1095,  # 3年
        "backup_frequency": "daily"
    },
    "confidential": {
        "encryption": True,
        "encryption_algorithm": "AES-256-GCM",
        "access_control": "authorized_users",
        "retention_days": 2555,  # 7年
        "backup_frequency": "daily",
        "audit_required": True
    },
    "restricted": {
        "encryption": True,
        "encryption_algorithm": "AES-256-GCM",
        "access_control": "privileged_users",
        "retention_days": 3650,  # 10年
        "backup_frequency": "real_time",
        "audit_required": True,
        "dlp_enabled": True  # Data Loss Prevention
    }
}

# データ保護実装
class DataProtection:
    def __init__(self, classification: str):
        self.config = DATA_CLASSIFICATION[classification]
        self.key_manager = KeyManager()
    
    def protect_data(self, data: any, field_name: str) -> dict:
        if not self.config["encryption"]:
            return {"data": data, "encrypted": False}
        
        # 機密フィールドの判定
        if self._is_sensitive_field(field_name):
            encrypted_data = self._encrypt_field(data)
            return {"data": encrypted_data, "encrypted": True}
        
        return {"data": data, "encrypted": False}
    
    def _is_sensitive_field(self, field_name: str) -> bool:
        sensitive_fields = [
            "password", "hashed_password", "api_key", "token",
            "private_key", "secret", "credential", "claude_context"
        ]
        return any(sensitive in field_name.lower() for sensitive in sensitive_fields)
```

---

## 5. インフラセキュリティ

### 5.1 Docker セキュリティ

```yaml
# docker-compose.security.yml
version: '3.8'

services:
  claude-session:
    # セキュリティオプション
    security_opt:
      - no-new-privileges:true
      - apparmor:docker-default
      - seccomp:./seccomp-profile.json
    
    # ケーパビリティ制限
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETUID  
      - SETGID
      - DAC_OVERRIDE
    
    # ファイルシステム制限
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,nodev,size=100m,mode=1777
      - /var/tmp:noexec,nosuid,nodev,size=100m,mode=1777
      - /run:noexec,nosuid,nodev,size=50m,mode=755
    
    # リソース制限
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
          pids: 100
        reservations:
          cpus: '0.25'
          memory: 128M
    
    # ネットワーク分離
    networks:
      - claude-internal
    network_mode: bridge
    
    # ユーザー制限
    user: "1000:1000"  # 非特権ユーザー
    
    # 環境変数最小化
    environment:
      - PYTHONPATH=/app
      - HOME=/tmp
      - USER=claude
    
    # ボリューム制限
    volumes:
      - type: bind
        source: ./user-workspace
        target: /workspace
        bind:
          propagation: rprivate
        read_only: false
      - type: tmpfs
        target: /tmp
        tmpfs:
          size: 100M
          mode: 1777

  nginx:
    # セキュリティヘッダー設定
    command: |
      nginx -g 'daemon off;' -c /etc/nginx/nginx-secure.conf

networks:
  claude-internal:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
    driver_opts:
      com.docker.network.bridge.enable_icc: "false"
      com.docker.network.bridge.enable_ip_masquerade: "true"
```

### 5.2 ネットワークセキュリティ

```nginx
# nginx-secure.conf
worker_processes auto;
error_log /var/log/nginx/error.log warn;

events {
    worker_connections 1024;
    use epoll;
}

http {
    # セキュリティヘッダー
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' wss: https:; font-src 'self'; object-src 'none'; media-src 'self'; frame-src 'none';" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Permissions-Policy "camera=(), microphone=(), geolocation=(), payment=(), usb=(), bluetooth=(), accelerometer=(), gyroscope=(), magnetometer=()";
    
    # サーバー情報隠蔽
    server_tokens off;
    more_clear_headers 'Server';
    more_clear_headers 'X-Powered-By';
    
    # レート制限
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    limit_conn_zone $binary_remote_addr zone=conn:10m;
    
    # SSL/TLS 設定
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    
    server {
        listen 443 ssl http2;
        server_name claude-code-client.local;
        
        # SSL 証明書
        ssl_certificate /etc/ssl/certs/server.crt;
        ssl_certificate_key /etc/ssl/private/server.key;
        
        # セキュリティ制限
        client_max_body_size 10M;
        client_body_timeout 10s;
        client_header_timeout 10s;
        keepalive_timeout 5s;
        
        # API レート制限
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            limit_conn conn 10;
            proxy_pass http://backend:8000;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # ログイン レート制限
        location /api/v1/auth/login {
            limit_req zone=login burst=5 nodelay;
            proxy_pass http://backend:8000;
        }
        
        # WebSocket プロキシ
        location /ws/ {
            proxy_pass http://backend:8000;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_read_timeout 86400;
        }
    }
    
    # HTTP → HTTPS リダイレクト
    server {
        listen 80;
        server_name _;
        return 301 https://$host$request_uri;
    }
}
```

### 5.3 ファイアウォール設定

```bash
# iptables セキュリティルール
#!/bin/bash

# デフォルトポリシー（拒否）
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# ループバック許可
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# 確立済み接続許可
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# SSH アクセス（管理用）
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT

# HTTP/HTTPS アクセス
iptables -A INPUT -p tcp --dport 80 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT

# PostgreSQL（内部ネットワークのみ）
iptables -A INPUT -p tcp -s 172.20.0.0/16 --dport 5432 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT

# DDoS 保護
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT

# 不正パケット遮断
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
iptables -A INPUT -p tcp --tcp-flags ALL ALL -j DROP
iptables -A INPUT -p tcp --tcp-flags ALL ACK,RST,SYN,FIN -j DROP
iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP

# ログ記録
iptables -A INPUT -j LOG --log-prefix "iptables denied: " --log-level 7

# 設定保存
iptables-save > /etc/iptables/rules.v4
```

---

## 6. アプリケーションセキュリティ

### 6.1 入力検証・サニタイゼーション

```python
# 入力検証設定
INPUT_VALIDATION = {
    "file_upload": {
        "max_size_mb": 10,
        "allowed_extensions": [
            ".py", ".js", ".ts", ".html", ".css", ".json", 
            ".yaml", ".yml", ".md", ".txt", ".sql", ".sh",
            ".dockerfile", ".gitignore", ".env.example"
        ],
        "blocked_extensions": [
            ".exe", ".bat", ".ps1", ".bin", ".so", ".dll",
            ".scr", ".vbs", ".jar", ".app", ".deb", ".rpm"
        ],
        "scan_for_malware": True,
        "quarantine_suspicious": True
    },
    
    "command_execution": {
        "allowed_commands": [
            "git", "npm", "pip", "python", "node", "ls", "cat",
            "grep", "find", "mkdir", "touch", "cp", "mv", "chmod"
        ],
        "blocked_commands": [
            "sudo", "su", "passwd", "useradd", "userdel",
            "systemctl", "service", "mount", "umount", "fdisk",
            "rm -rf", "dd", "mkfs", "parted", "crontab"
        ],
        "argument_sanitization": True,
        "timeout_seconds": 30
    },
    
    "api_input": {
        "max_json_size_kb": 100,
        "max_string_length": 1000,
        "sanitize_html": True,
        "check_sql_injection": True,
        "check_xss": True,
        "unicode_normalization": True
    }
}

# 入力検証実装
import re
import html
import unicodedata
from typing import Any, List, Dict

class InputValidator:
    def __init__(self):
        self.sql_injection_patterns = [
            r"(\bunion\b.*\bselect\b)",
            r"(\bselect\b.*\bfrom\b)",
            r"(\binsert\b.*\binto\b)",
            r"(\bupdate\b.*\bset\b)",
            r"(\bdelete\b.*\bfrom\b)",
            r"(\bdrop\b.*\btable\b)",
            r"(--)",
            r"(/\*.*\*/)"
        ]
        self.xss_patterns = [
            r"<script[^>]*>.*?</script>",
            r"javascript:",
            r"on\w+\s*=",
            r"<iframe[^>]*>",
            r"<object[^>]*>",
            r"<embed[^>]*>"
        ]
    
    def validate_string(self, value: str, max_length: int = 1000) -> str:
        if not isinstance(value, str):
            raise ValueError("Value must be string")
        
        # 長さチェック
        if len(value) > max_length:
            raise ValueError(f"String too long: {len(value)} > {max_length}")
        
        # Unicode正規化
        value = unicodedata.normalize('NFKC', value)
        
        # XSS チェック
        for pattern in self.xss_patterns:
            if re.search(pattern, value, re.IGNORECASE):
                raise ValueError("Potential XSS detected")
        
        # SQL インジェクション チェック
        for pattern in self.sql_injection_patterns:
            if re.search(pattern, value, re.IGNORECASE):
                raise ValueError("Potential SQL injection detected")
        
        # HTML エスケープ
        return html.escape(value)
    
    def validate_file_path(self, path: str) -> str:
        # パストラバーサル攻撃防止
        if ".." in path or path.startswith("/"):
            raise ValueError("Invalid file path")
        
        # 正規化
        normalized = os.path.normpath(path)
        if normalized != path:
            raise ValueError("Path contains traversal")
        
        return normalized
    
    def validate_command(self, command: str, args: List[str]) -> bool:
        allowed_commands = INPUT_VALIDATION["command_execution"]["allowed_commands"]
        blocked_commands = INPUT_VALIDATION["command_execution"]["blocked_commands"]
        
        # コマンド許可チェック
        if command not in allowed_commands:
            return False
        
        # 禁止コマンドチェック
        full_command = f"{command} {' '.join(args)}"
        for blocked in blocked_commands:
            if blocked in full_command:
                return False
        
        # 引数サニタイゼーション
        for arg in args:
            if self._contains_shell_metacharacters(arg):
                return False
        
        return True
    
    def _contains_shell_metacharacters(self, arg: str) -> bool:
        shell_chars = [";", "&", "|", ">", "<", "`", "$", "(", ")", "{", "}"]
        return any(char in arg for char in shell_chars)
```

### 6.2 出力エンコーディング

```python
# 出力エンコーディング設定
OUTPUT_ENCODING = {
    "html_escape": True,
    "json_escape": True,
    "log_sanitization": True,
    "error_message_sanitization": True,
    
    # 機密情報マスキング
    "sensitive_patterns": [
        r"password['\"]?\s*[:=]\s*['\"]?([^'\"\\s]+)",
        r"api[_-]?key['\"]?\s*[:=]\s*['\"]?([^'\"\\s]+)",
        r"token['\"]?\s*[:=]\s*['\"]?([^'\"\\s]+)",
        r"secret['\"]?\s*[:=]\s*['\"]?([^'\"\\s]+)",
        r"Bearer\s+([A-Za-z0-9\-\._~\+\/]+=*)",
        r"(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
    ]
}

class OutputEncoder:
    def __init__(self):
        self.sensitive_patterns = [re.compile(p, re.IGNORECASE) for p in OUTPUT_ENCODING["sensitive_patterns"]]
    
    def sanitize_log_message(self, message: str) -> str:
        # 機密情報マスキング
        for pattern in self.sensitive_patterns:
            message = pattern.sub(r"\1***MASKED***", message)
        
        # 制御文字除去
        message = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', message)
        
        return message
    
    def sanitize_error_message(self, error: Exception) -> str:
        message = str(error)
        
        # スタックトレース情報の除去
        message = re.sub(r'/[a-zA-Z0-9_/]+\.py', '[FILE_PATH]', message)
        message = re.sub(r'line \d+', 'line [LINE_NUM]', message)
        
        # 機密情報マスキング
        return self.sanitize_log_message(message)
```

### 6.3 CSRF 保護

```python
# CSRF 保護設定
CSRF_CONFIG = {
    "token_length": 32,
    "token_lifetime_hours": 24,
    "same_site_cookie": "strict",
    "secure_cookie": True,
    "check_referer": True,
    "allowed_origins": [
        "https://localhost:8000",
        "https://claude-code-client.local"
    ]
}

# CSRF 保護実装
import secrets
import hmac
import hashlib
from datetime import datetime, timedelta

class CSRFProtection:
    def __init__(self, secret_key: str):
        self.secret_key = secret_key.encode()
    
    def generate_token(self, user_id: int) -> str:
        timestamp = int(datetime.utcnow().timestamp())
        random_part = secrets.token_urlsafe(16)
        
        # HMAC 署名生成
        message = f"{user_id}:{timestamp}:{random_part}".encode()
        signature = hmac.new(self.secret_key, message, hashlib.sha256).hexdigest()
        
        return f"{user_id}:{timestamp}:{random_part}:{signature}"
    
    def verify_token(self, token: str, user_id: int) -> bool:
        try:
            token_user_id, timestamp, random_part, signature = token.split(":")
            
            # ユーザーID チェック
            if int(token_user_id) != user_id:
                return False
            
            # 有効期限チェック
            token_time = datetime.fromtimestamp(int(timestamp))
            if datetime.utcnow() - token_time > timedelta(hours=24):
                return False
            
            # 署名検証
            message = f"{token_user_id}:{timestamp}:{random_part}".encode()
            expected_signature = hmac.new(self.secret_key, message, hashlib.sha256).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
            
        except (ValueError, TypeError):
            return False
```

---

## 7. 監査・ログ

### 7.1 監査ログ設定

```python
# 監査ログ設定
AUDIT_CONFIG = {
    "enabled": True,
    "log_level": "INFO",
    "log_format": "json",
    "log_rotation": "daily",
    "retention_days": 365,
    
    # 監査対象イベント
    "audit_events": [
        "user_login", "user_logout", "user_login_failed",
        "session_created", "session_started", "session_stopped", "session_deleted",
        "file_read", "file_write", "file_delete", "file_upload", "file_download",
        "project_created", "project_deleted", "project_shared",
        "worktree_created", "worktree_deleted", "worktree_sync",
        "permission_changed", "role_assigned", "role_removed",
        "system_config_changed", "security_violation",
        "api_key_created", "api_key_revoked"
    ],
    
    # 機密情報フィルタ
    "filter_sensitive_data": True,
    "sensitive_fields": [
        "password", "api_key", "token", "secret", "private_key"
    ],
    
    # 改ざん防止
    "tamper_protection": True,
    "digital_signature": True,
    "log_encryption": True
}

# 監査ログ実装
import json
import logging
from datetime import datetime
from typing import Dict, Any
import hashlib
import hmac

class AuditLogger:
    def __init__(self, config: dict):
        self.config = config
        self.logger = self._setup_logger()
        self.secret_key = os.getenv("AUDIT_LOG_SECRET_KEY", "").encode()
    
    def _setup_logger(self) -> logging.Logger:
        logger = logging.getLogger("audit")
        logger.setLevel(logging.INFO)
        
        # ファイルハンドラー
        handler = logging.handlers.TimedRotatingFileHandler(
            filename="/var/log/claude/audit.log",
            when="D",  # 日次ローテーション
            interval=1,
            backupCount=self.config["retention_days"],
            encoding="utf-8"
        )
        
        # JSON フォーマッター
        formatter = logging.Formatter(
            '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": %(message)s}'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
    
    def log_event(self, event_type: str, user_id: int, details: Dict[str, Any]) -> None:
        if event_type not in self.config["audit_events"]:
            return
        
        # 機密データフィルタリング
        filtered_details = self._filter_sensitive_data(details)
        
        # 監査ログエントリ作成
        audit_entry = {
            "event_type": event_type,
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat(),
            "details": filtered_details,
            "request_id": details.get("request_id"),
            "ip_address": details.get("ip_address"),
            "user_agent": details.get("user_agent")
        }
        
        # デジタル署名追加
        if self.config["digital_signature"]:
            audit_entry["signature"] = self._sign_entry(audit_entry)
        
        # ログ出力
        self.logger.info(json.dumps(audit_entry, ensure_ascii=False))
    
    def _filter_sensitive_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        if not self.config["filter_sensitive_data"]:
            return data
        
        filtered = {}
        for key, value in data.items():
            if any(sensitive in key.lower() for sensitive in self.config["sensitive_fields"]):
                filtered[key] = "***FILTERED***"
            elif isinstance(value, dict):
                filtered[key] = self._filter_sensitive_data(value)
            else:
                filtered[key] = value
        
        return filtered
    
    def _sign_entry(self, entry: Dict[str, Any]) -> str:
        # 署名計算用のエントリコピー（署名フィールド除く）
        entry_copy = {k: v for k, v in entry.items() if k != "signature"}
        entry_string = json.dumps(entry_copy, sort_keys=True, ensure_ascii=False)
        
        return hmac.new(
            self.secret_key,
            entry_string.encode(),
            hashlib.sha256
        ).hexdigest()
    
    def verify_log_integrity(self, log_file_path: str) -> bool:
        """ログファイルの整合性検証"""
        try:
            with open(log_file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    try:
                        entry = json.loads(line.strip())
                        if "signature" in entry:
                            stored_signature = entry.pop("signature")
                            calculated_signature = self._sign_entry(entry)
                            
                            if not hmac.compare_digest(stored_signature, calculated_signature):
                                print(f"Log integrity violation at line {line_num}")
                                return False
                    except json.JSONDecodeError:
                        print(f"Invalid JSON at line {line_num}")
                        return False
            
            return True
            
        except FileNotFoundError:
            print(f"Log file not found: {log_file_path}")
            return False
```

### 7.2 システム監視

```python
# システム監視設定
MONITORING_CONFIG = {
    "metrics_collection": {
        "enabled": True,
        "interval_seconds": 60,
        "retention_days": 30
    },
    
    # アラート条件
    "alerts": {
        "failed_login_threshold": 5,  # 5分間で5回失敗
        "failed_login_window_minutes": 5,
        
        "api_error_rate_threshold": 0.05,  # エラー率5%
        "api_error_window_minutes": 5,
        
        "disk_usage_threshold": 0.85,  # 使用率85%
        "memory_usage_threshold": 0.90,  # 使用率90%
        "cpu_usage_threshold": 0.80,  # 使用率80%
        
        "session_timeout_threshold": 30,  # 30分無応答
        "websocket_disconnect_threshold": 10  # 10回/分の切断
    },
    
    # 通知設定
    "notification": {
        "email_alerts": True,
        "slack_webhook": True,
        "admin_email": "admin@claude-code-client.com"
    }
}

# セキュリティ監視実装
class SecurityMonitor:
    def __init__(self):
        self.failed_login_attempts = {}
        self.api_error_counts = {}
        self.suspicious_activities = []
    
    def monitor_login_attempts(self, ip_address: str, success: bool) -> None:
        current_time = datetime.utcnow()
        
        if not success:
            # 失敗カウント更新
            if ip_address not in self.failed_login_attempts:
                self.failed_login_attempts[ip_address] = []
            
            self.failed_login_attempts[ip_address].append(current_time)
            
            # 古い記録を削除（5分以内のみ保持）
            cutoff_time = current_time - timedelta(minutes=5)
            self.failed_login_attempts[ip_address] = [
                timestamp for timestamp in self.failed_login_attempts[ip_address]
                if timestamp > cutoff_time
            ]
            
            # アラート判定
            if len(self.failed_login_attempts[ip_address]) >= 5:
                self._trigger_security_alert(
                    "REPEATED_LOGIN_FAILURES",
                    f"IP {ip_address} has {len(self.failed_login_attempts[ip_address])} failed login attempts"
                )
    
    def monitor_api_errors(self, endpoint: str, error_occurred: bool) -> None:
        current_time = datetime.utcnow()
        
        if endpoint not in self.api_error_counts:
            self.api_error_counts[endpoint] = {"total": 0, "errors": 0, "last_reset": current_time}
        
        self.api_error_counts[endpoint]["total"] += 1
        if error_occurred:
            self.api_error_counts[endpoint]["errors"] += 1
        
        # 5分毎にリセット
        if current_time - self.api_error_counts[endpoint]["last_reset"] > timedelta(minutes=5):
            error_rate = self.api_error_counts[endpoint]["errors"] / self.api_error_counts[endpoint]["total"]
            
            if error_rate > 0.05:  # 5% エラー率
                self._trigger_security_alert(
                    "HIGH_API_ERROR_RATE",
                    f"Endpoint {endpoint} has error rate {error_rate:.2%}"
                )
            
            # カウンタリセット
            self.api_error_counts[endpoint] = {"total": 0, "errors": 0, "last_reset": current_time}
    
    def detect_suspicious_activity(self, user_id: int, activity: str, details: dict) -> None:
        suspicious_patterns = [
            "rapid_session_creation",
            "unusual_file_access",
            "privilege_escalation_attempt",
            "abnormal_api_usage",
            "geographic_anomaly"
        ]
        
        if activity in suspicious_patterns:
            self.suspicious_activities.append({
                "user_id": user_id,
                "activity": activity,
                "details": details,
                "timestamp": datetime.utcnow(),
                "severity": self._calculate_severity(activity, details)
            })
            
            self._trigger_security_alert(
                "SUSPICIOUS_ACTIVITY_DETECTED",
                f"User {user_id} performed suspicious activity: {activity}"
            )
    
    def _trigger_security_alert(self, alert_type: str, message: str) -> None:
        alert = {
            "type": alert_type,
            "message": message,
            "timestamp": datetime.utcnow(),
            "severity": "HIGH" if "SECURITY" in alert_type else "MEDIUM"
        }
        
        # ログ記録
        logging.getLogger("security").warning(json.dumps(alert))
        
        # 管理者通知
        self._send_admin_notification(alert)
    
    def _send_admin_notification(self, alert: dict) -> None:
        # メール通知実装
        # Slack通知実装
        pass
```

---

## 8. インシデント対応

### 8.1 インシデント分類

```python
INCIDENT_CLASSIFICATION = {
    "P1_CRITICAL": {
        "description": "システム全体停止・重大セキュリティ侵害",
        "response_time_minutes": 15,
        "escalation_time_minutes": 30,
        "examples": [
            "データベース侵害",
            "管理者権限奪取",
            "大規模データ漏洩",
            "システム全面停止"
        ]
    },
    "P2_HIGH": {
        "description": "部分的機能停止・中程度セキュリティ侵害",
        "response_time_minutes": 60,
        "escalation_time_minutes": 120,
        "examples": [
            "認証システム障害",
            "個人情報漏洩",
            "DDoS攻撃",
            "重要機能停止"
        ]
    },
    "P3_MEDIUM": {
        "description": "性能低下・軽微なセキュリティ問題",
        "response_time_minutes": 240,
        "escalation_time_minutes": 480,
        "examples": [
            "性能低下",
            "ログイン失敗増加",
            "不審なアクセス",
            "設定ミス"
        ]
    },
    "P4_LOW": {
        "description": "軽微な問題・予防的対応",
        "response_time_minutes": 1440,  # 24時間
        "escalation_time_minutes": 2880,  # 48時間
        "examples": [
            "軽微なエラー増加",
            "設定変更要求",
            "予防的対応"
        ]
    }
}
```

### 8.2 インシデント対応手順

```python
# インシデント対応ワークフロー
class IncidentResponse:
    def __init__(self):
        self.incident_id = None
        self.classification = None
        self.status = "NEW"
        self.timeline = []
    
    def detect_incident(self, alert_data: dict) -> str:
        """インシデント検知・分類"""
        self.incident_id = self._generate_incident_id()
        self.classification = self._classify_incident(alert_data)
        self.status = "DETECTED"
        
        self._log_timeline("DETECTED", "Incident detected and classified")
        
        # 自動初期対応
        self._initiate_containment(alert_data)
        
        # 通知
        self._notify_response_team()
        
        return self.incident_id
    
    def _classify_incident(self, alert_data: dict) -> str:
        """インシデント分類ロジック"""
        severity_indicators = {
            "database_breach": "P1_CRITICAL",
            "admin_compromise": "P1_CRITICAL", 
            "data_exfiltration": "P1_CRITICAL",
            "system_outage": "P1_CRITICAL",
            
            "auth_failure": "P2_HIGH",
            "privilege_escalation": "P2_HIGH",
            "ddos_attack": "P2_HIGH",
            
            "suspicious_login": "P3_MEDIUM",
            "performance_degradation": "P3_MEDIUM",
            
            "config_drift": "P4_LOW"
        }
        
        alert_type = alert_data.get("type", "").lower()
        for indicator, classification in severity_indicators.items():
            if indicator in alert_type:
                return classification
        
        return "P3_MEDIUM"  # デフォルト分類
    
    def _initiate_containment(self, alert_data: dict) -> None:
        """自動封じ込め対応"""
        containment_actions = {
            "repeated_login_failures": self._block_suspicious_ip,
            "privilege_escalation": self._revoke_user_access,
            "data_exfiltration": self._enable_emergency_mode,
            "system_compromise": self._isolate_system
        }
        
        alert_type = alert_data.get("type", "").lower()
        for pattern, action in containment_actions.items():
            if pattern in alert_type:
                action(alert_data)
                break
    
    def _block_suspicious_ip(self, alert_data: dict) -> None:
        """疑わしいIPアドレスをブロック"""
        ip_address = alert_data.get("ip_address")
        if ip_address:
            # iptables ルール追加
            os.system(f"iptables -A INPUT -s {ip_address} -j DROP")
            self._log_timeline("CONTAINMENT", f"Blocked IP address: {ip_address}")
    
    def _revoke_user_access(self, alert_data: dict) -> None:
        """ユーザーアクセス無効化"""
        user_id = alert_data.get("user_id")
        if user_id:
            # データベースでユーザー無効化
            # セッション強制終了
            self._log_timeline("CONTAINMENT", f"Revoked access for user: {user_id}")
    
    def _enable_emergency_mode(self, alert_data: dict) -> None:
        """緊急モード有効化"""
        # 読み取り専用モード
        # 管理者のみアクセス許可
        # 詳細監視有効化
        self._log_timeline("CONTAINMENT", "Emergency mode enabled")
    
    def _isolate_system(self, alert_data: dict) -> None:
        """システム分離"""
        # 外部ネットワーク遮断
        # 内部通信制限
        # フォレンジック準備
        self._log_timeline("CONTAINMENT", "System isolation initiated")
    
    def _log_timeline(self, action: str, description: str) -> None:
        """インシデントタイムライン記録"""
        self.timeline.append({
            "timestamp": datetime.utcnow(),
            "action": action,
            "description": description
        })
        
        # 監査ログに記録
        audit_logger.log_event("incident_action", 0, {
            "incident_id": self.incident_id,
            "action": action,
            "description": description
        })
```

### 8.3 フォレンジック対応

```python
# デジタルフォレンジック設定
FORENSICS_CONFIG = {
    "evidence_preservation": {
        "automatic_snapshots": True,
        "snapshot_retention_days": 90,
        "memory_dump_on_critical": True,
        "log_preservation": True
    },
    
    "chain_of_custody": {
        "digital_signatures": True,
        "access_logging": True,
        "tamper_evidence": True,
        "time_synchronization": "ntp"
    },
    
    "investigation_tools": {
        "log_analysis": "elasticsearch",
        "traffic_analysis": "wireshark",
        "file_analysis": "autopsy",
        "memory_analysis": "volatility"
    }
}

class ForensicsHandler:
    def __init__(self):
        self.evidence_chain = []
    
    def preserve_evidence(self, incident_id: str) -> None:
        """証拠保全"""
        evidence_id = self._generate_evidence_id()
        
        # システムスナップショット
        snapshot_path = self._create_system_snapshot(incident_id)
        
        # メモリダンプ
        memory_dump_path = self._create_memory_dump(incident_id)
        
        # ログファイル保全
        log_archive_path = self._archive_logs(incident_id)
        
        # ネットワークトラフィック保全
        traffic_capture_path = self._capture_network_traffic(incident_id)
        
        # 証拠チェーン記録
        self._record_evidence_chain(evidence_id, {
            "incident_id": incident_id,
            "snapshot": snapshot_path,
            "memory_dump": memory_dump_path,
            "logs": log_archive_path,
            "traffic": traffic_capture_path,
            "timestamp": datetime.utcnow(),
            "handler": "system_auto"
        })
    
    def _create_system_snapshot(self, incident_id: str) -> str:
        """システムスナップショット作成"""
        snapshot_path = f"/forensics/snapshots/{incident_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        
        # Docker コンテナスナップショット
        containers = subprocess.check_output(["docker", "ps", "-q"]).decode().strip().split('\n')
        for container in containers:
            if container:
                subprocess.run([
                    "docker", "commit", container, 
                    f"forensic-snapshot-{incident_id}-{container}"
                ])
        
        return snapshot_path
    
    def _create_memory_dump(self, incident_id: str) -> str:
        """メモリダンプ作成"""
        dump_path = f"/forensics/memory/{incident_id}_memory.dump"
        
        # メモリダンプ実行（実装依存）
        # subprocess.run(["dd", "if=/proc/kcore", f"of={dump_path}"])
        
        return dump_path
    
    def _archive_logs(self, incident_id: str) -> str:
        """ログファイル保全"""
        archive_path = f"/forensics/logs/{incident_id}_logs.tar.gz"
        
        # ログファイル圧縮・署名
        log_files = [
            "/var/log/claude/audit.log",
            "/var/log/claude/security.log", 
            "/var/log/claude/application.log",
            "/var/log/nginx/access.log",
            "/var/log/nginx/error.log"
        ]
        
        subprocess.run([
            "tar", "czf", archive_path
        ] + log_files)
        
        # デジタル署名
        self._sign_evidence_file(archive_path)
        
        return archive_path
```

---

## 9. セキュリティ運用

### 9.1 定期セキュリティタスク

```yaml
# セキュリティ運用スケジュール
security_schedule:
  daily:
    - log_review
    - failed_login_analysis
    - system_resource_check
    - backup_verification
    
  weekly:
    - vulnerability_scan
    - access_review
    - certificate_expiry_check
    - incident_metrics_review
    
  monthly:
    - penetration_test
    - user_access_audit
    - security_policy_review
    - threat_intelligence_update
    
  quarterly:
    - security_assessment
    - disaster_recovery_test
    - security_training
    - risk_assessment_update
    
  annually:
    - security_audit
    - compliance_review
    - security_policy_update
    - emergency_response_drill
```

### 9.2 セキュリティメトリクス

```python
# セキュリティKPI
SECURITY_METRICS = {
    "authentication": {
        "failed_login_rate": "target < 1%",
        "account_lockout_rate": "target < 0.1%",
        "password_reset_rate": "target < 5%",
        "session_timeout_rate": "target < 2%"
    },
    
    "authorization": {
        "privilege_escalation_attempts": "target = 0",
        "unauthorized_access_attempts": "target < 10/day",
        "role_changes": "monitor all changes"
    },
    
    "data_protection": {
        "data_classification_coverage": "target = 100%",
        "encryption_coverage": "target = 100%",
        "backup_success_rate": "target > 99%",
        "data_retention_compliance": "target = 100%"
    },
    
    "incident_response": {
        "detection_time": "target < 15 minutes",
        "response_time": "target < 60 minutes",
        "resolution_time": "target < 4 hours",
        "false_positive_rate": "target < 5%"
    },
    
    "vulnerability_management": {
        "critical_patch_time": "target < 24 hours",
        "high_patch_time": "target < 7 days",
        "vulnerability_scan_coverage": "target = 100%",
        "patch_success_rate": "target > 95%"
    }
}
```

### 9.3 セキュリティ自動化

```python
# セキュリティ自動化スクリプト
class SecurityAutomation:
    def __init__(self):
        self.scheduler = BackgroundScheduler()
        self.setup_automated_tasks()
    
    def setup_automated_tasks(self):
        """自動化タスクの設定"""
        
        # 日次タスク
        self.scheduler.add_job(
            self.daily_security_check,
            'cron', hour=2, minute=0
        )
        
        # 週次タスク
        self.scheduler.add_job(
            self.weekly_vulnerability_scan,
            'cron', day_of_week=0, hour=3, minute=0
        )
        
        # 月次タスク
        self.scheduler.add_job(
            self.monthly_access_review,
            'cron', day=1, hour=4, minute=0
        )
        
        self.scheduler.start()
    
    def daily_security_check(self):
        """日次セキュリティチェック"""
        try:
            # ログ分析
            self._analyze_security_logs()
            
            # 失敗ログイン分析
            self._analyze_failed_logins()
            
            # リソース使用量チェック
            self._check_resource_usage()
            
            # バックアップ検証
            self._verify_backups()
            
            # レポート生成
            self._generate_daily_report()
            
        except Exception as e:
            logging.error(f"Daily security check failed: {e}")
    
    def weekly_vulnerability_scan(self):
        """週次脆弱性スキャン"""
        try:
            # ポートスキャン
            self._run_port_scan()
            
            # Webアプリケーションスキャン
            self._run_web_app_scan()
            
            # 依存関係スキャン
            self._run_dependency_scan()
            
            # 設定チェック
            self._check_security_configurations()
            
            # レポート生成
            self._generate_vulnerability_report()
            
        except Exception as e:
            logging.error(f"Weekly vulnerability scan failed: {e}")
    
    def monthly_access_review(self):
        """月次アクセスレビュー"""
        try:
            # 非アクティブユーザー検出
            inactive_users = self._detect_inactive_users()
            
            # 過剰権限検出
            excessive_privileges = self._detect_excessive_privileges()
            
            # アクセスパターン分析
            access_anomalies = self._analyze_access_patterns()
            
            # レビューレポート生成
            self._generate_access_review_report(
                inactive_users, excessive_privileges, access_anomalies
            )
            
        except Exception as e:
            logging.error(f"Monthly access review failed: {e}")
```

---

## 付録

### A. セキュリティチェックリスト

```yaml
# デプロイ前セキュリティチェックリスト
pre_deployment_checklist:
  authentication:
    - [ ] JWT設定の検証
    - [ ] パスワード要件の確認
    - [ ] セッション設定の検証
    - [ ] 多要素認証準備の確認
    
  authorization:
    - [ ] RBAC設定の検証
    - [ ] API権限の確認
    - [ ] リソースアクセス制御の検証
    
  data_protection:
    - [ ] 暗号化設定の検証
    - [ ] 鍵管理の確認
    - [ ] データ分類の実装
    - [ ] バックアップ暗号化の確認
    
  infrastructure:
    - [ ] Docker セキュリティ設定
    - [ ] ネットワーク分離の確認
    - [ ] ファイアウォール設定
    - [ ] SSL/TLS設定の検証
    
  application:
    - [ ] 入力検証の実装
    - [ ] 出力エンコーディングの実装
    - [ ] CSRF保護の実装
    - [ ] セキュリティヘッダーの設定
    
  monitoring:
    - [ ] 監査ログの設定
    - [ ] セキュリティ監視の実装
    - [ ] アラート設定の確認
    - [ ] インシデント対応手順の準備
```

### B. セキュリティツール設定

```bash
# セキュリティスキャンツール設定
#!/bin/bash

# OWASP ZAP 自動スキャン
docker run -t owasp/zap2docker-stable zap-baseline.py \
    -t https://localhost:8000 \
    -J zap-report.json \
    -r zap-report.html

# Trivy 脆弱性スキャン
trivy image claude-code-client:latest \
    --format json \
    --output trivy-report.json

# Bandit Python セキュリティスキャン
bandit -r /app/backend \
    -f json \
    -o bandit-report.json

# Safety 依存関係チェック
safety check --json --output safety-report.json
```

---

**作成者**: Claude Code セキュリティチーム  
**レビュー**: セキュリティエンジニア  
**承認日**: 2025-06-25  
**次回レビュー**: 四半期毎  
**セキュリティレベル**: 機密